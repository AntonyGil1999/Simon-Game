#include <LiquidCrystal.h>

#define ON 0
#define OFF 1

// Affectation du brochage des LEDs
int leds[4] = {10, 11, 12, 13};

// Affectation du brochage des Boutons
int buttons[4] = {0, 1, 2, 3};

// Potentiomètre
int sensorValue = 0;
int potentiometerPin = A0;

// LCD
const int rs = 8, en = 9, d4 = 4, d5 = 5, d6 = 6, d7 = 7;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

// Pattern et score
int pattern[20];
int patternLength = 2;
int score = 0;
int patternCount = 0;

// delais (en ms) entre deux éclairage de LED
int delayTime = 0;



void setup() 
{
  // Initialisation des LEDs
  for (int i = 0; i < 4; i++)
  {
      // Configuration de la pin leds[i] en sortie
      pinMode(leds[i], OUTPUT);
      // On eteint la LED
      digitalWrite(leds[i], OFF);
  } 

  // Initialisation des Boutons
  for (int i = 0; i < 4; i++)
   pinMode(buttons[i], INPUT);

  sensorValue = analogRead(potentiometerPin);
  delayTime = map(sensorValue, 0, 1023, 200, 1000);

  // LCD
  // On défini la taille de l'écran
  // 16 colonnes et 2 lignes
  lcd.begin(16, 2);
  updateLCD(0);
}



void loop()
{
  delay(1500);
  randomSeed(millis());
  // Lire potentiomètre pour ajuster la vitesse
  sensorValue = analogRead(potentiometerPin);
  delayTime = map(sensorValue, 0, 1023, 200, 1000);

  // Générer le pattern
  for (int i = 0; i < patternLength; i++)
   pattern[i] = random(0, 4);
 
  // Afficher le pattern
  showPattern();

  // Tour du joueur
  bool ok = playerTurn();
  if (ok) {
    score += patternLength;
    patternLength++;
  } else {
    score -= patternLength;
    patternLength--;
    if (patternLength < 2) patternLength = 2;
    errorFlash();
  }  
  patternCount++;
  updateLCD(0);
  delay(1000);
  if (patternCount >= 10 || score < 0)
   gameOver();
  updateLCD(1);
  delay(1000);
  updateLCD(0);
  
}

// Affiche la séquence LED
void showPattern() {
  for (int i = 0; i < patternLength; i++)
  {
    int numero_de_led = pattern[i];
    int pin_led = leds[numero_de_led];
    digitalWrite(pin_led, ON);
    delay(delayTime);
    digitalWrite(leds[pattern[i]], OFF);
    delay(delayTime);
  }
}

// Tour du joueur
bool playerTurn() {
  unsigned long time_0;
  // nombre de ms à cet instant
  time_0 = millis();
  for (int i = 0; i < patternLength; i++)
  {
    int pressed = waitForButton(time_0);
    if (pressed != pattern[i]) return false;
  }
  return true;
}

// Attente d'un bouton pressé puis relâché
int waitForButton(unsigned long t0)
{
  // on continu à scrupter les boutons tant qu'il ne s'est pas écoulé 15s depuis l'affichage du pattern
  while ( (millis() - t0) < 15000)
  {
    for (int i = 0; i < 4; i++)
    {      
      // Le bouton i est-il appuyé ( = LOW) ?
      if (digitalRead(buttons[i]) == LOW)
      {
        delay(20);
        // On verifie qu'on le voie 2 fois appuyé
        if (digitalRead(buttons[i]) == LOW) 
        {
          //on attend qu'il relache le bouton
          while (digitalRead(buttons[i]) == LOW)
          {

          }
          
          //on attend 20ms avant de scrupter le bouton suivant
          delay(20);
          return i;
        }
      }
    }
  }
  // si on arrive là c'est qu'on a mis plus de 15s depuis l'affichage du pattern
  return -1;
}

// Flash LED erreur
void errorFlash() {
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 4; j++) digitalWrite(leds[j], ON);
    delay(200);
    for (int j = 0; j < 4; j++) digitalWrite(leds[j], OFF);
    delay(200);
  }
}

// Mise à jour LCD
void updateLCD(int ready)
 {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Score: ");
  lcd.print(score);
  lcd.setCursor(0, 1);
  if (ready)
  {
    lcd.print("Ready ?");
  }
  else
  {
    lcd.print("P:");
    lcd.print(patternLength);
    lcd.print(" N:");
    lcd.print(patternCount);
    lcd.print(" D:");
    lcd.print(delayTime);
    lcd.print("ms");
  }
}

// Fin de partie
void gameOver() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("GAME OVER!");
  lcd.setCursor(0, 1);
  lcd.print("Score: ");
  lcd.print(score);
  while (true);
}